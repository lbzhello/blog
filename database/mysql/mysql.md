## 基本数据类型

#### 整数

|类型|TINYINT|SMALLINT|MEDIUMINT|INT|BIGINT
|:--:|:--:|:--:|:--:|:--:|:--:|
|BIT|8|16|24|32|64|

> UNSIGNED 属性可以使大小提高一倍

#### 实数

DECIMAL(m, n) 用于存储精确实数, m 表示总长度， n 表示小数部分。DECIMAL 只是一种存储格式，

浮点类型 FLOAT 使用 4 个字节存储，DOUBLE 使用 8 字节存储。MySQL 使用 DOUBLE 作为内部浮点计算的类型。

#### 字符串

VARCHAR 可变长字符串（如果使用 ROW_FORMAT=FIXED 创建，则是定长的）。VARCHAR 需要使用 1 或 2 个额外字节记录字符串的长度，如果列的长度小于 255 字节，则使用 1 个字节，否则使用 2 个字节。因此一个 VARCHAR(10) 的列需要 11 个字节的存储空间，VARCHAR(1000) 需要 1002 个字节的存储空间。

由于 VARCHAR 是变长的，所以 UPDATE 的时可能使行占用更多的空间，若页内没有更多的空间可以存储， MyISAM 会将行拆成不同的片段存储， InnoDB 会分裂页来使行可以放进页内。

CHAR 是定长的，MySQL 会删除所有的末尾空格，并且用空格填充。

VARCHAR(200) 和 VARCHAR(10) 存储 'hello' 的空间开销是一样的，但在使用临时表排序是会分配更多的空间，表现也更糟糕。

BINARY 和 VARBINARY 用于存储二进制字符串，即存储的是字节码而不是字符。MySQL 用 '\0' 填充 BINARY, 检索时不会去掉填充值。

#### 大数据量的字符串

BLOB 采用二进制存储，没有排序规则和字符集

|类型|TINYBLOB|SMALLBLOB/BLOB|MEDIUMBLOB|LONGBLOB|
|:--:|:--:|:--:|:--:|:--:|:--:|
|最大|255|65K|16M|4G|

TEXT 采用字符存储， 有排序规则和字符集

|类型|TINYTEXT|SMALLTEXT/TEXT|MEDIUMTEXT|LONGTEXT|
|:--:|:--:|:--:|:--:|:--:|:--:|
|字节|255|65K|16M|4G|

BLOG 和 TEXT 只对每个列前 max_sort_length 字节排序。如果只需要排序前面一小部分字符，可以减小 max_sort_length 的配置，或者使用 SUSTRING(column, length)。

#### ENUM

ENUM 使用整数存储， ENUM 使用内部的整数而不是定义的字符串进行排序。

> 可以是用 FIELD() 函数指定排序的顺序，这样 MySQL 无法使用索引消除排序。
> 如： select e from enum_test order by FIELD(e, 'apple', 'dog', 'fish')

#### 日期和时间

DATETIME 范围 1001-9999 年，精度为秒。他把日期和时间封装到格式为 YYYYMMDDHHMMSS 的整数中，与失去无关。使用 8 个字节的存储空间。

TIMESTAMP 类型保存了从 1970-01-01(格林尼治标准时间)以来的秒数，和 UNIX 时间戳相同，依赖于不同的时区，使用 4 个字节的存储空间，只能表示 1970-2038 年。

> MySQL 提供了 FROM_UNIXTIME() 把 UNIX 时间戳转化为日期；UNIX_TIMESTAMP() 函数把日期转化为 UNIX 时间戳。

> MySQL 默认会更新第一个 TIMESTAMP 列的值

#### 位数据类型

#### BIT

BIT 最大长度 64 位。BIT 检索式会以字符串显示，计算时用它表示的数字。例如对于 '00111001'(二进制值为 57)，检索时得到的是字符码为 57 的字符串 "9", 在上下文场景中是数字 57

#### SET

MySQL 使用一系列打包的位集合表示 SET, 缺点是改变列的定义的代价比较高。

#### 主键

足够的前提下尽量选择较小的数据类型，能用 TINYINT 就不要用 INT

整数通常是标识列最好的选择，因为他们很快并且可以使用 AUTO_INCREMENT; 

如果可能，尽量避免使用字符串作为表示列，因为它们很耗费空间，并且通常比整数慢。（MyISAM 默认对字符串使用压缩索引，会导致查询更慢）

随机字符串作为索引时，插入操作会随机的写到索引的不同位置，从而导致页分裂、磁盘随机访问，以及对于聚簇存储引擎产生聚簇索引碎片，使得插入变慢；也会是 SELECT 语句变慢，因为逻辑上相邻的行分布在磁盘和内存的不同位置；也不利于缓存，因为热点数据分散了

#### 特殊类型

IPV4 可以用整数存储，MySQL 提供了 INET_ATON() 和 INET_NTOA() 用于 IP 地址和整数之间的转换


## 架构



## 存储引擎

#### InnoDB

InnoDB 通过 MVCC 支持高并发，并且实现了四个默认的隔离级别，默认隔离级别是 REPEATABLE READ(可重复读)，并且通过间隙锁(next-key locking)策略防止幻读的出现。

InnoDB 的主键索引是聚簇索引，聚簇索引对逐渐查询有很高的性能，不过他的二级索引（secondary index, 非主键索引）中必须包含主键列。如果主键列很大，其他所有索引都会很大，因此主键应尽可能的小。InnoDB 的存储格式是平台独立的。**在大多数情况下，你应该选择InnoDB 引擎**。

#### MyISAM

MyISAM 提供了全文索引，压缩，空间函数等特性，但 MyISAM 不支持事务和行级锁，而且崩溃后无法安全恢复。对于只读的数据，或者表比较小，并且可以容忍修复（repair）操作，可以使用 MyISAM。

## 选择合适的存储引擎

大多数情况下，InnoDB 都是正确的选择，它也是 MySQL 的默认存储引擎（5.5 版本后）。除非需要用到某些 InnoDB 不具备的特性，并且没有其他方法可以替代，否则都应该优先选择 InnoDB 引擎。

### 如何选择存储引擎

#### 事务

#### 备份

#### 崩溃恢复

#### 特有的特性
只有 MyISAM 支持地理空间搜索

## 索引

索引可以让服务器快速定位到表的指定位置。因为 B-Tree 索引按照顺序存储数据，所以 MySQL 可以用来做 ORDER BY 和 GROUP BY 操作。因为数据是有序的，所以 B-Tree 也会将相关的列值存储在一起。最后，因为索引中存储了实际的值，所以某些查询只使用索引就能完成全部的查询（覆盖索引）。总结下来，索引有如下优点：

1. 索引大大减少了服务器需要扫描的数据量。
2. 索引可以帮助服务器避免排序和临时表。
3. 索引可以将随机 IO 变为顺序 IO。

MySQL 中索引是在存储引擎层而不是在服务层实现的。

B-Tree 索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描获取需要的数据。

存储引擎以不同的方式使用 B-Tree 索引，性能也各有不同，各有优劣。MyISAM 使用前缀压缩使得索引更小；InnoDB 按照原数据格式进行存储。MyISAM 索引通过数据的物理位置引用被索引的行；InnoDB 根据主键引用被索引的行。

关于索引可参考 [B+Tree 索引](btree.md)

B+Tree 索引适用于全值键，键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。索引对如下的查询类型有效。

假设有如下表：

```sql
create table people (
    people_id int unsigned not null primary key auto_increment comment '主键',
    pname varhcar(64) not null default '' comment '姓名',
    age int unsigned not null default now() comment '年龄'
) engine=InnoDB default charset=utf8
comment='用户表';

alter table people add index ix_pname_age (pname, age);
```

**全值匹配**  
全值匹配指的是和索引中的所有列进行匹配。如上面的索引可以查找 pname = 'tom' 并且 age = 22 的人。

**匹配最左前缀**  
只使用索引的第一列。前面的索引可以查找所有 pname = 'tom' 的人。

**匹配列前缀**  
只能匹配某一列的开头部分。前面的索引可以查找所有 pname like 'T%' 的人。

**匹配范围值**  
匹配第一列某个范围值。比如 pname 在 aaa 和 ddd 之间的人。

**精确匹配前面列并范围匹配后面的列**  
匹配 pname = 'Tom' 并且 age 在 20-25 之间的人。

**覆盖索引**
返回的列中的值都在索引中，即只访问索引的查询。比如  
```sql
select pname, age from people where pname = 'Tom' and age > 18;
```
由于 pname 和 age 的值都在索引中，所以无需访问数据行。

**索引排序**  
因为索引树中的节点都是有序的，所以索引可以用于查询中的 order by 操作。

### 索引失效

- 不符合最左前缀规则。比如 where pname like '%om' 无法使用索引。

- 不能跳过索引中的列。比如 wherer age = 22 无法使用索引。

- 如果某个列为范围查询，则其后面的列无法使用索引，比如 where pname like 'Tom%' and age = 22 此时 age 无法使用索引。

- or 语句前后没有同时使用索引。

- 数据类型出现隐式转化。比如 varchar 不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描。

- 在索引列上使用 IS NULL 或 IS NOT NULL操作。索引是不索引空值的，所以这样的操作不能使用索引，可以用其他的办法处理，例如：数字类型，判断大于0，字符串类型设置一个默认值，判断是否等于默认值即可。

- 在索引字段上使用not，<>，!=。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。 优化方法： key<>0 改为 key>0 or key<0。

- 对索引字段进行计算操作。

- 在索引字段上使用函数。（8.0 可以使用）;

- 当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效。（数据少，区分度少）。

### explain
explain 可以查看 SQL 语句的执行情况, 判断有没有使用索引。

用法可参考 [MySQL 性能优化神器 Explain 使用分析](https://segmentfault.com/a/1190000008131735)

### 高性能索引策略

#### 独立的列

索引不能是表达式的一部分，也不能是函数的参数。

```sql
# 无法使用索引
select pname from people where people_id + 1 = 5;
```

#### 前缀索引和索引选择性
有时候需要索引很长的字符列，这回让索引变得大且慢。通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。索引的选择性越高则查询效率越高，因为选择性高的行可以让 MySQL 在查询是过滤掉更多的行。唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。

> 索引选择性是指**不重复的索引值**（也称为基数，cardinality）和**数据表的记录总数（T）**的比值，范围在 1/T - 1 之间。

一般情况下某个列前缀的选择性也是足够的，足以满足查询性能。对于 BLOB, TEXT 或者很长的 VARCHAR 类型的列，必须使用前缀索引，因为 MySQL 不允许索引这些列的完整长度。

要选择足够长的前缀以保证较高的选择性，同时又不能太长（一遍节约空间），尽量是前缀索引的选择性趋近于索引整个列。

可以通过如下方法确定某个列的前缀索引：

```sql
# 计算列的选择性
select count(distinct pname)/count(*) from people;

# 计算前缀索引的选择性，它应该趋近于列的选择性
select count(distinct left(pname, 3))/count(*) as sel3,
    count(distinct left(pname, 4))/count(*) as sel4,
    count(distinct left(pname, 5))/count(*) as sel5,
    count(distinct left(pname, 6))/count(*) as sel6,
    count(distinct left(pname, 7))/count(*) as sel7,
from people;

# 计算前缀索引的出现次数，这个值应该尽量小
# 以便于前缀索引有较大的区分度
select count(*) as cnt, left(pname, 7) as pref
from pname group by pref order by cnt desc;
```

**注意：** MySQL 无法使用前缀索引做 GROUP BY 和 ORDER BY，也无法使用前缀索引做覆盖扫变！

#### 多列索引

#### 选择合适的索引列顺序

将选择性最高的列放到索引的最前列。这个法则通常没有随机 IO 和排序重要，考虑问题需要更全面，比如排序和分组。

#### 聚簇索引

InnoDB 的聚簇索引实在同一个结构中保存了 B-Tree 索引和数据行。他的数据行存放在存放在索引的叶子页中。

MySQL 通过主键聚集数据，如果没有主键，InnoDB 会选择一个非空的索引代替。如果没有这样的索引 InnoDB 会隐式的定义一个主键作为聚簇索引。InnoDB 只聚集在同一个页面中的记录。包含相邻键值的页面可能会相距很远。

聚簇索引的优点：

- 可以把相关的数据保存在一起。读取数据的时候避免随机 IO。
- 数据访问更快。聚簇索引将索引和数据保存在同一个 B-Tree 中，因此从聚簇索引中获取数据通常比非聚簇索引中查找快。
- 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

聚簇索引的缺点：

- 聚簇索引最大限度的提高了 IO 密集型应用的性能，但如果数据存储在内存中，则访问的顺序就没那么重要了，聚簇索引也就没有什么优势了。

- 插入速度严重以来由于插入的顺序。按照主键的顺序插入是加载数据到 InnoDB 表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用 OPTIMIZE TABLE 命令重新组织一下表。

- 更新聚簇索引列的代价很高，因为会强制 InnoDB 将每个被更新的行移动到新的位置。

- 插入新行或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题，导致表占用更多的磁盘空间。

- 二级索引（非聚簇索引）可能会很大，因为二级索引的叶子节点中包含了引用行的主键列值。

- 二级索引需要两次索引查找，而不是一次。即先从二级索引中找到主键值，在根据主键值从聚簇索引中查找对应的行。

#### 在 InnoDB 中按照主键顺序插入行

随机插入的缺点：
- 写入的目标也可能已经刷新到磁盘上并且从缓存中移除，或者还没有被加载到缓存中， InnoDB 在插入之前不得不先找到并从磁盘读取目标也到内存中。这将导致大量的随机 I/O。
- 因为写入时乱序的，会导致频繁的页分裂，移动大量的数据，一次修改最少需要修改三个页面而不是一个。
- 频繁的页分裂导致页变得稀疏并被不规则的填充，索引最终数据会有碎片。

> 如果主键不是顺序插入，最好执行 OPTIMIZE TABLE 命令重建表并优化页的填充。

### 覆盖索引

覆盖索引指的是查询返回的列都在索引中。这能极大的提高查询效率，减少 I/O 次数，避免二级索引的两次查询。MySQL 只能使用 B-Tree 索引做覆盖索引。

当发起一个索引覆盖查询时，EXPLAIN 的 Extra 列可以看到“Using index” 的信息。

### 使用索引扫描来排序
MySQL 通过两种方式可以生成有序的结果：通过排序操作；或者按照索引顺序扫描；如果 EXPLAIN 出来的 type 列的值位 index，则说明 MySQL 索引扫描来做排序。

扫描索引本身是很快的，因为只需要从一条索引记录移动到下一条索引记录。但如果索引不能覆盖查询所需的全部列，那就不得不没扫描一条索引记录就都回表查询一次对应的行。这基本都是随机 I/O，因此只按索引顺序读取数据的速度通常要比顺序的全表扫描慢，尤其是在 I/O 密集型的工作负载时。

MySQL 可以使用同一个索引既满足排序有用于查找行。

只有当索引的顺序和 ORDER BY 字句的顺序完全一致，并且所有的排序方向都一样（倒叙或正序）时，MySQL 才能使用索引来对结果做排序。多表关联查询，只有当 ORDER BY 子句引用的字段全部为第一个表时，才能使用索引做排序。

#### 压缩索引（前缀压缩）
MyISAM 使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况下能极大地提高性能。压缩索引无法使用二分查找，只能从头开始扫描。对于 CPU 密集型应用，压缩索引的查找速度会慢很多，但是对于 I/O 密集型应用，对某些查询的好处会比成本多好多。

#### 冗余和重复索引
MySQL 允许在相同的列上创建多个索引，无论是有意的还是无意的。MySQL 需要单独的维护重复的索引，并且优化器在查询的时候也需要逐个的进行考虑，这会影响性能。因此应当尽量避免创建重复索引。

#### 索引和锁
索引可以让查询锁定更少的行，对性能会有好处。虽然 InnoDB 的行锁效率很高，内存使用也很少，但是锁定行的时候仍然会带来开销；其次，锁定查过需要的行会增加锁争用并减少并发性。


## 查询性能优化
#### 1. 查询优化
#### 2. 索引优化
#### 3. 库表结构优化

### 慢查询基础筛选大量的数据
查询性能低下最基本的原因是访问的数据太多。某些查询可能不可避免的需要筛选大量的数据，但这并不常见。大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。这也是索引工作的原理。

### 分析

1. 确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列。
2. 确认 MySQL 服务器层是否在分析大量超过需要的行。

#### 是否向数据库请求了不需要的数据

#### MySQL 是否在扫描额外的记录
对于 MySQL，最简单的衡量查询开销的三个指标有：响应时间、扫描的行数、返回的行数
#### 响应时间
响应时间包括服务时间和排队时间，服务时间指数据库处理这个查询真正花了多长时间；排队时间指服务器因等待某些资源而没有真正执行查询的时间-可能时等待 I/O 操作，锁等待等。

#### 扫描的行数和返回的行数
在 EXPLAIN 语句中的 type 列反映了访问类型。访问类型有很多种，全表扫描、索引扫描、范围扫描、唯一索引查询、常熟引用等。以上速度从慢到快，扫描的行数也是从小到大。如果查询没有找到合适的访问类型，解决的方法通常就是增加一个合适的索引。索引让 MySQL 以最高效，扫描行数最少的方式找到需要的记录。

一般 MySQL 能够使用如下三种方式应用 WHERE 条件，从好到坏依次是：
1. 在索引中使用 WHERE 条件过滤不匹配的记录。这是在存储引擎层完成的。
2. 使用索引覆盖扫描（在 Extra 列中出现 Using index）。这是在 MySQL 服务器层完成的，但无需回表查询记录。
3. 从数据表中返回数据，然后过滤不满足条件的记录（Extra 中出现 Using where）。这是在 MySQL 服务器层完成的，MySQL 先从数据表中读出记录然后过滤。

如果发现查询需要扫描大量的数据但只返回少量的行，那么可以通过下面的技巧去优化它：
1. 使用索引覆盖扫描。
2. 该表库表结构。例如使用单独的额汇总表。
3. 重写这个复杂的查询，让 MySQL 优化器能够以更优化的方式去执行这个查询。

### 重构查询的方式

#### 一个简单的查询还是多个复杂的查询。
设计查询的时候一个需要考虑的重要问题是，是否需要将一个复杂的查询分成多个简单的查询。

MySQL 从设计上让连接和断开连接都很轻量级都很轻量级，在返回一个小的查询结果方面很高效。现代的网络速度比以前快的多，无论是带宽还是延迟。这让一个复杂的查询分解为多个简单的查询并不会特别影响到查询效率。

另外，将一个大的查询分解成多个小的查询，可以将服务器上原本一次性的压力分散到一个很长的时间段中，就可以大大降低对服务器的影响，还可以减少对锁的持有时间。

**复杂查询的缺点：**
一个大的查询可能需要一次锁住很多的数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。

#### 分解关联查询
优点：
1. 让缓存的效率更高。
2. 将查询分解后，执行单个查询可以减少锁的竞争。
3. 在应用层进行关联，可以更容易的对数据库进行拆分，更容易做到高性能和可扩展。
4. 可以减少冗余记录的查询。在应用层做关联查询，意味着对某条记录应用只需要查询一次，而在数据表中做关联查询，则可能需要重复的访问一部分数据。从这点看，这样的重构还可能会减少网路和内存的消耗。
5. 这样做相当于在应用中实现了哈希关联，而不是使用 MySQL 的嵌套循环关联，某些场景哈希关联的效率要高很多。

### 查询执行的基础
MySQL 是如何优化和执行查询的：
1. 客户端发送一条查询给服务器。
2. 服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。
3. 服务器端记性 SQL 解析、预处理，再由优化器生成对应的执行计划。
4. MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询。
5. 将结果返回给客户端。

#### MySQL 客户端/服务器通信协议
MySQL 客户端和服务器之间的通信协议是“半双工”的，这意味着在任何一个时刻，要么是有服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。

这种协议让 MySQL 通信简单快速，但也从很多方面限制了 MySQL, 一个明显的限制是无法进行流量控制。一旦一端开始发送消息，另一端接收完整个消息才能响应它。这就像抛球游戏：在任何时刻，只有一个人能控制球，而且只有控制球的人才能将球抛回去。



### 优化示例

#### 哈希索引

InnoDB 支持自适应哈希索引（adaptive hash index）。当某些索引值被使用得非常频繁时，它会在内存基于 B+Tree 之上再创建一个哈希索引。这是一个完全自动的、内部的行为，用户无法控制或配置，不过如果有必要，可以关闭这个功能。

创建自定义哈希索引。如下查询

```sql
select id from some_url where url = 'https://www.mysql.com';
```
当需要存储大量的 url, 并且需要根据 url 进行查找，如果使用 B-Tree 存储 url，存储的内容就会很大。

可以删除 url 列上的索引，新增一个索引列 url_crc, 使用 CRC32 做哈希。

```sql
select id from some_url where url = 'https://www.mysql.com' and url_crc = crc32('https://www.mysql.com');
```

注意不要是用 sha1() 或 md5() 作为哈希值，因为它们计算出来的值是非常长的字符串，会浪费大量的空间，比较时也会更慢。

如果数据量非常大，可能产生大量的哈希冲突，可以自己实现一个 64 位函数。

